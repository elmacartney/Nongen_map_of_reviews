---
title: "Question3"
author: "Shinichi Nakagawa"
date: '2022-05-23'
output: html_document
---

## The main question

> How are authors of the SR literature connected across different countries and disciplines?

1.  Frequency map of authors (1st author)

2.  Cord plot or network plot between countries and fields via

### Setup and data organisation

```{r setup, results = 'hide'}

knitr::opts_chunk$set(echo = TRUE)

library(readxl)
library(plyr)
library(here)
library(tibble)
library(dplyr)
library(tidyverse)
library(stringr)
library(knitr)
library(forcats)
library(ggplot2)
#library(hrbrthemes) #for ggplot2
library(bibliometrix)
library(igraph)
library(patchwork)
library(RColorBrewer)
library(wordcloud2)
library(migest)
library(circlize)
library(igraph)
library(stringi)
library(tidystringdist)
library(stringdist)
library(fuzzyjoin)
```

```{r, results = 'hide'}
#manually extracted data
xldata <- here("data", "Data_extraction_postcrosschecking.xlsx")

# xldata <- read_excel(here("Data_extraction_postcrosschecking.xlsx"))
#note that here packeage doen't work with data wrangling code below

# #bibliometric data
# bib <- convert2df("./bibliometric.bib", dbsource = "scopus", format = "bibtex")

bib <- convert2df(here("data", "bibliometric2.bib"), dbsource = "scopus", format = "bibtex")
```

```{r, results = 'hide'}
#Splitting list of tabs into separate dataframes
excel_sheets(path = xldata)
tab_names <- excel_sheets(path = xldata)


#creating a list of dataframes per tab
list_all <- lapply(tab_names, function(x) read_excel(path = xldata, sheet = x))

#assigning tab names to each dataframe
names(list_all) <- tab_names

#get dataframes out of list
list2env(list_all, .GlobalEnv)
```

# Bibliometric analysis


```{r, eval = FALSE, message = FALSE, warning = FALSE}
keywords <- S$MostRelKeywords
words<-keywords[,1]
freq<-as.numeric(keywords[,2])
prob<-freq/sum(freq)

Fig7 <- wordcloud2(data.frame(words, prob), shuffle = TRUE, size = 0.5, color = 'random-dark')

Fig7

#TODO put this in supplementary material

```

## Fig - connection via disapline

# this is good - collobraiton can be done
# We need connection by co-citation or conneciton by coupling


```{r, results = 'hide'}

# Data
Publication_info_discipline <- merge(Publication_info, Review_info)

# matching with 1st author and title
# mapping data
Fields <- Publication_info_discipline %>%
  mutate(title = tolower(unlist(lapply(data.frame(t(str_split_fixed(title, " ", n = 15)[,1:14])), 
                                       function(x) str_c(x, collapse  = " ")))),
         ntitle = paste(tolower(str_split_fixed(id, "\\_", n = 2)[,1]), title, sep = " "),
         ntitle = trimws(ntitle)) %>% 
  select(ntitle, discipline_code)

# bib data
Bib_names <- bib %>% rownames_to_column(., var = "mat_names") %>% 
  mutate(TI2 = tolower(unlist(lapply(data.frame(t(str_split_fixed(TI, " ", n = 15)[,1:14])), 
                                     function(x) str_c(x, collapse  = " ")))),
         # stri_trans_general = getting rid of special letters
         name2 = stri_trans_general(tolower(str_split_fixed(SR, " ", n = 2)[,1]), "latin-ascii"),
         TI2 = paste(name2, TI2, sep= " "),
         TI2 = trimws(TI2)) %>% 
  select(TI2, mat_names)
 

# Joined <- stringdist_left_join(Bib_names, Fields, 
#                 by = c(TI2 = "ntitle"),
#                 max_dist = 10,
#                 method = "lv") 
# 
# dim(Joined)
# 
# # this seems to be the best we can do
# Joined

# This is to match the highest matches between two author-title columns
#stringdist(Bib_names$TI2, Fields$ntitle[1], method = 'osa')
pos <- lapply(Bib_names$TI2, function(x) stringdist(Fields$ntitle, x))
pos2<- map_dbl(pos, which.min)

# these are looking good - both have the perfect matches (at least at a glance)
Bib_names$TI2
Fields$ntitle[pos2]

# now we can merge two datasets 
Bib_names$discipline_code <- Fields$discipline_code[pos2]

## The same idea as above but this does not work
# tidy_comb_sw <- tidy_comb_all(Fields$ntitle, Bib_names$TI2[1])
# 
# compact<- tidy_stringdist(tidy_comb_sw, method= "osa") %>% slice(which.min(osa))
# 
# compact<- tidy_stringdist(tidy_comb_sw, method= "osa") %>% group_by(V1) %>% 
#  slice(which.min(osa))
# 
# compact2<- tidy_stringdist(tidy_comb_sw, method= "jw") %>% group_by(V2) %>% 
#  summarise(min = min(jw))

#test <- data.frame(t(str_split_fixed(bib$TI, " ", n = 12)[,1:10]))
#vector(lapply(test, function(x) str_c(x, collapse  = " ")))


# # works OK - but not a general solution
# # attempting to match with author name and year and it won't work well
# 
# # creating name_year - the first name (element of) and year combined
# Fields <- Review_info %>% mutate(name_year = paste(tolower(str_split_fixed(Review_info$id, "\\_", n = 2)[,1]), 
#                                                   str_sub(Review_info$id, -4, -1), sep = "_")) %>% 
#   select(name_year, discipline_code)
# 
# # agin creating name_year - the first name (element of) and year combined
# Bib_names <- bib %>% rownames_to_column(., var = "mat_names") %>% 
#   mutate(name_year = paste(tolower(str_split_fixed(bib$SR, " ", n = 2)[,1]), 
#                                                   bib$PY, sep = "_"),
#          name_year = stri_trans_general(name_year, "latin-ascii")) %>% 
#   select(name_year, mat_names)
# 
# #match(Fields$name_year, Bib_names$name_year)
# 
# match(levels(factor(Fields$name_year)),levels(factor(Bib_names$name_year)))
# 
# 
# # "anwer_2022" <- "anwer_2021"
# # "besson_2016" <-  "besson_2016" 
# # "chaves_2021" <- "chaves_2020"
# # "grueber_2018" <- "grueber_2017"
# # "menting_2019" <- "menting_2018"
# 
# 
# # joining
# 
# Bib_names %>% left_join(Fields, by = ("name_year" = "name_year") )  -> Bib_names2
# 
# #CR <- citations(bib, field = "article", sep = ";")
# 
# #mat <- cocMatrix(bib, Field = "CR", sep = ";")

# Creating matrix for bibliometric coupling
NetMatrix <- biblioNetwork(bib, analysis = "coupling", network = "references", sep = ";")
#NetMatrix2 <- biblioNetwork(bib, analysis = "co-citation", network = "references", sep = ";")

# net=networkPlot(NetMatrix,  normalize = "salton", weighted=NULL, n = 10,
#                 Title = "Authors' Coupling", type = "fruchterman", size=5,size.cex=T,remove.multiple=TRUE,
#                 labelsize=0.8,label.n=10,label.cex=F)

#NetMatrix <- biblioNetwork(mat, analysis = "coupling", network = "authors", sep = ";")

# forcing into a nromal matrix
net_matrix <- as.matrix(NetMatrix)
diag(net_matrix) <- 0 #get rid of counts for the same papers

# replacing names with discipline_code
rownames(net_matrix) <- Bib_names$discipline_code
colnames(net_matrix) <- Bib_names$discipline_code

# reducing matrix according to discipline_code
rect_matrix<- t(rowsum(t(net_matrix), group = colnames(net_matrix), na.rm = T))
small_matrix <- rowsum(rect_matrix, group = rownames(rect_matrix))
# getting rid of lower trangle (as this is duplication of info)
small_matrix[lower.tri(small_matrix)] <- 0 

# TODO 
# you can look at this matrix
small_matrix

grid.cols <- setNames(rainbow(length(unlist(dimnames(small_matrix)))), union(rownames(small_matrix), colnames(small_matrix)))
par(mar = c(0, 0, 0, 0), mfrow = c(1, 2))


# chord diagram
circos.clear()
fig <- chordDiagramFromMatrix(small_matrix, grid.col = grid.cols)
# 
# # it is a bit hard to understand - need to come back if you want to label differently
# circos.track(track.index = 1, panel.fun = function(x, y) {
#     circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
#         facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
# }, bg.border = NA) # here set bg.border to NA is important

# pdf("Shared_citation.pdf")
# dev.off()

```


```{r}
## Figure 8 - Country collaboration

bib2 <- metaTagExtraction(bib, Field = "AU1_CO", sep = ";") 
bib2 <- metaTagExtraction(bib2, Field = "AU_CO", sep = ";") 

NetMatrix2 <- biblioNetwork(bib2, analysis = "collaboration", 
                           network = "countries", sep = ";")
#results <- biblioAnalysis(bib3, sep = ";")
#S2 <- summary(object = results, k=20 ,pause = FALSE) 
#MostProdCountries <- S2$MostProdCountries
#MostProdCountries$Articles <- as.numeric(MostProdCountries$Articles)
#countries <- MostProdCountries[1:8,'Country']
#countries <- trimws(countries)


net_matrix2 <- as.matrix(NetMatrix2)
#net_matrix2 <-net_matrix[rownames(NetMatrix2), countries]
diag(small_matrix) <- 0 #get rid of collaboration with same country

# getting rid of lower trangle (as this is duplication of info)
net_matrix2[lower.tri(net_matrix2)] <- 0 


circos.clear()
grid.col <- setNames(rainbow(length(unlist(dimnames(net_matrix2)))), union(rownames(net_matrix2), colnames(net_matrix2)))
par(mar = c(0, 0, 0, 0), mfrow = c(1, 2))

fig1 <- chordDiagram(net_matrix2, annotationTrack = "grid", preAllocateTracks = 1, grid.col = grid.col)

circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
  xlim = get.cell.meta.data("xlim")
  ylim = get.cell.meta.data("ylim")
  sector.name = get.cell.meta.data("sector.index")
  circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
  circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
}, bg.border = NA)


#fig1
# circos.clear()
# fig1 <- chordDiagram(net_matrix2, grid.col = grid.col, annotationTrack = "grid", 
#     preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(net_matrix2))))))
# # we go back to the first track and customize sector labels
# circos.track(track.index = 1, panel.fun = function(x, y) {
#    sector.name = get.cell.meta.data("sector.index")
#     circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
#         facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
#   circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
# }, bg.border = NA) 

#https://www.riinu.me/2022/02/world-map-ggplot2/


```

```

